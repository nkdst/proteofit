---
title: "09_WGCNA"
author: "Nick Diercksen"
date: "Last compiled on `r format(Sys.time())`"
output:
  html_notebook:
    code_folding: hide
    toc: yes
    toc_float: yes
    df_print: paged
editor_options: 
  chunk_output_type: inline
  markdown: 
    wrap: 72
params:
  FCutoff:
    label: cutoff for the log2FoldChange
    value: 1
  pCutoff:
    label: "cutoff for the adjusted p-Value"
    value: 0.01
  reevaluate:
    label: Should all calculations and database lookups be done again or just e.g.
      graphics regenerated
    value: no
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(ggplot2)

library(DESeq2)

# BiocManager::install("WGCNA", force = T)
library(WGCNA)
```

```{r plotSettings, include=FALSE}
condition_pal <- c("WT"= "#00C3C6","KO"= "#FF6C67")

tissue_pal <- c(gastroc = "orange", soleus="purple")
```

```{r loadData, include=FALSE}
# loading DESeq2 results (`res.gastroc`, and `res.soleus`):
load("./data/Robjects/02_DDS.RData")
```

# About

> [!note]

> ⚠️ This part is abandoned! This seemingly will not yield any new
> information (because we already have the DE and so on.) We can just do
> this manually and discard `WGCNA`.

Using the Weighted Gene Correlation Networks for Analysis (WGCNA) to
create a network hopefully showing any similar gene (clusters) between
the tissues, created by knocking out Nfe2l1.\n

Steps:

1.  Creating the network (can this be done for both tissues? =\> I would
    assume so, I just need to merge both datasets)
2.  create some (graph) visualizations?

Followed Tutorial:
<https://bioinformaticsworkbook.org/tutorials/wgcna.html#gsc.tab=0>

# TODO:

-   [ ] apply WGCNA for both tissues (incorporate soleus), so that the
    original question can be answered.

# data prep

## normalization

### VarianceStabilizing Transformation

instead of z-scoring the data, variance stabilizing Transformation
should be applied: (It stabilizes the variance across the range of
expression values)

#### example VST

currently using the `VST`:

```{r VSTgastroc}
print("-------------- variance of variance stabilized counts: --------------")
# (=> scaling down to two digits?)
wpn_vsd.gastroc <- getVarianceStabilizedData(dds.gastroc)
rv_wpn.gastroc <- rowVars(wpn_vsd.gastroc)
summary(rv_wpn.gastroc)

print("-------------- vs variance of normalized counts: --------------")
counts.gastroc <- counts(dds.gastroc, normalized=TRUE)
rv_norm.gastroc <- rowVars(counts.gastroc)
summary(rv_norm.gastroc)
```

```{r eval=FALSE, inlude=FALSE}
# TODO: add visualization for transformation? something like:
# https://bioconductor.org/packages/release/workflows/vignettes/rnaseqGene/inst/doc/rnaseqGene.html#the-variance-stabilizing-transformation-and-the-rlog
#:
dds <- estimateSizeFactors(dds)

df <- bind_rows(
  as_data_frame(log2(counts(dds, normalized=TRUE)[, 1:2]+1)) %>%
         mutate(transformation = "log2(x + 1)"),
  as_data_frame(assay(vsd)[, 1:2]) %>% mutate(transformation = "vst"),
  as_data_frame(assay(rld)[, 1:2]) %>% mutate(transformation = "rlog"))
  
colnames(df)[1:2] <- c("x", "y")  

lvls <- c("log2(x + 1)", "vst", "rlog")
df$transformation <- factor(df$transformation, levels=lvls)

ggplot(df, aes(x = x, y = y)) + geom_hex(bins = 80) +
  coord_fixed() + facet_grid( . ~ transformation)  
```

To avoid any batcheffects, the normalization is applied before merging
both datasets:

```{r vst}
vsd.gastroc <- vst(dds.gastroc) %>% assay()
vsd.soleus <- vst(dds.soleus) %>% assay()

```

### shrinking dataset: quantile by row Variance

-   filtering by variance with quantiles is done per tissue (before
    merging).

-   taking the union of genes with 'significant' variance (of the
    quantiles) from each tissue to merge the `vsd` matrices.

-   [ ] is that OK?

```{r quantileFiltering}
rv.gastroc <- rowVars(vsd.gastroc)
rv.soleus <- rowVars(vsd.soleus)

# obtaining the .75 quantile
q75.gastroc <- quantile( rv.gastroc, .75)
q75.soleus <- quantile( rv.soleus, .75)

# union of the q75 names:
q75.names.gastroc <- vsd.gastroc[ rv.gastroc > q75.gastroc, ] %>% row.names()
q75.names.soleus <- vsd.soleus[ rv.soleus > q75.soleus, ] %>% row.names()
q75.names <- unique(c(q75.names.gastroc, q75.names.soleus))

# merging both matrices:
vsd.both <- merge(vsd.gastroc, vsd.soleus, by = 0, suffixes = c(".GA", ".SO")) %>% 
  filter(Row.names %in% q75.names) %>% 
  tibble::column_to_rownames("Row.names")
```

# WGCNA

```{r}
# transpose for WGCNA
input_mat = t(vsd.both)
allowWGCNAThreads()    # allow multi-threading (optional)

# Choose a set of soft-thresholding powers
powers = c(c(1:10), seq(from = 12, to = 20, by = 2))

# Call the network topology analysis function
sft = pickSoftThreshold(
  input_mat,             # <= Input data
  #blockSize = 30,
  powerVector = powers,
  verbose = 5
  )
```

```{r plotSoftThresholds}
par(mfrow = c(1,2));
cex1 = 0.9;

plot(sft$fitIndices[, 1],
     -sign(sft$fitIndices[, 3]) * sft$fitIndices[, 2],
     xlab = "Soft Threshold (power)",
     ylab = "Scale Free Topology Model Fit, signed R^2",
     main = paste("Scale independence")
)
text(sft$fitIndices[, 1],
     -sign(sft$fitIndices[, 3]) * sft$fitIndices[, 2],
     labels = powers, cex = cex1, col = "red"
)
abline(h = 0.90, col = "red") # TODO: out of scope (for q95)!
plot(sft$fitIndices[, 1],
     sft$fitIndices[, 5],
     xlab = "Soft Threshold (power)",
     ylab = "Mean Connectivity",
     type = "n",
     main = paste("Mean connectivity")
)
text(sft$fitIndices[, 1],
     sft$fitIndices[, 5],
     labels = powers,
     cex = cex1, col = "red")
```

```{r}
picked_power = 12
temp_cor <- cor  
cor <- WGCNA::cor         # Force it to use WGCNA cor function (fix a namespace conflict issue)
netwk <- blockwiseModules(input_mat,                # <= input here

                          # == Adjacency Function ==
                          power = picked_power,                # <= power here
                          networkType = "signed",

                          # == Tree and Block Options ==
                          deepSplit = 2,
                          pamRespectsDendro = F,
                          # detectCutHeight = 0.75,
                          minModuleSize = 30,
                          maxBlockSize = 4000,

                          # == Module Adjustments ==
                          reassignThreshold = 0,
                          mergeCutHeight = 0.25,

                          # == TOM == Archive the run results in TOM file (saves time)
                          saveTOMs = T,
                          saveTOMFileBase = "ER",

                          # == Output Options
                          numericLabels = T,
                          verbose = 3)
```

## looking at modules

```{r}
# Convert labels to colors for plotting
mergedColors = labels2colors(netwk$colors)
# Plot the dendrogram and the module colors underneath
plotDendroAndColors(
  netwk$dendrograms[[1]],
  mergedColors[netwk$blockGenes[[1]]],
  "Module colors",
  dendroLabels = FALSE,
  hang = 0.03,
  addGuide = TRUE,
  guideHang = 0.05 )
```

```{r}
table(netwk$colors)
```

## Relate Module (cluster) Assignments to Treatment Groups

```{r}
module_df <- data.frame(
  gene_id = names(netwk$colors),
  colors = labels2colors(netwk$colors)
)

module_df[1:5,]

readr::write_delim(module_df,
            file = "gene_modules.txt",
            delim = "\t")
```

## eigengenes

```{r}
# Get Module Eigengenes per cluster
MEs0 <- moduleEigengenes(input_mat, mergedColors)$eigengenes

# Reorder modules so similar modules are next to each other
MEs0 <- orderMEs(MEs0)
module_order = names(MEs0) %>% gsub("ME","", .)

# Add treatment names
MEs0$treatment = row.names(MEs0)

# tidy & plot data
mME = MEs0 %>%
  tidyr::pivot_longer(-treatment) %>%
  mutate(
    name = gsub("ME", "", name),
    name = factor(name, levels = module_order)
  )

mME %>% ggplot(., aes(x=treatment, y=name, fill=value)) +
  geom_tile() +
  theme_bw() +
  scale_fill_gradient2(
    low = "blue",
    high = "red",
    mid = "white",
    midpoint = 0,
    limit = c(-1,1)) +
  theme(axis.text.x = element_text(angle=90)) +
  labs(title = "Module-trait Relationships", y = "Modules", fill="corr")
```

# Questions

-   [ ] should I generally use ´varianceStabilizedData\` ?

-   [ ] should the dataset be reduced using quantiles (like in the
    tutorial)

    -   [ ] =\> check if the normalization I did in the beginning,
        actually is applied to both tissues at the same time, not for
        each
    -   [ ] is this above correct?

-   [ ]

-   [ ] should the varianceStabilizingTransformation be applied? Are
    these values better for statistical analysis?

-   [ ] and if, should it be applied to both tissues at the same time?
    or per tissue

    -   [ ] because the function can only be applied on a dds object I
        believe
