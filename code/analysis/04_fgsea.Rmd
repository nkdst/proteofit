---
title: "04_GSEA analysis"
author: "Nick Diercksen"
date: "Last compiled on `r format(Sys.time())`"
output:
  html_document:
    toc: yes
    df_print: paged
  html_notebook:
    toc: yes
    toc_float: yes
editor_options:
  chunk_output_type: inline
params:
  FCutoff:
    label: cutoff for the log2FoldChange
    value: 1
  pCutoff:
    label: "cutoff for the adjusted p-Value"
    value: 0.01
  fgsea.maxSize:
    label: "parameter for `fgsea`: 'Maximal size of a gene set to test. All pathways above the threshold are excluded.'"
    value: 200
  reevaluate:
    label: Should all calculations and database lookups be done again or just e.g.
      graphics regenerated
    value: no
  condition_pal: !r c("WT"= "#00C3C6","KO"= "#FF6C67")
  tissue_pal: !r c(gastroc = "orange", soleus="purple")
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(fgsea)
library(ggplot2)
library(ggpubr)
library(gridExtra)
library(eulerr)
library(plotly, include.only = "ggplotly")
```

```{r load_rdata, include=FALSE}
perform_fgsea <- params$reevaluate

load("./data/Robjects/02_annot.RData") # for entrezgene_id
load("./data/Robjects/03_DDS.RData")   # for `stat` values from DESeq results
```

# creating ranks

the `ranks` will be a `named num`, with `entrezgene_id` as name and `stat` (Wald Test) as metric

```{r getting_ranks}
getRanks <- function(res, annot) {
  # only taking genes which have entrezgene_ids assigned to them
  genes_with_entrez <- select(annot, GeneID, entrezgene_id) %>% 
    filter(!is.na(entrezgene_id))
  
  ranks <- as.data.frame(res) %>%
    tibble::rownames_to_column("GeneID") %>%
    merge(genes_with_entrez, by = "GeneID") %>%
    arrange(desc(stat)) %>% 
    select(entrezgene_id, stat) %>% 
    tibble::deframe() # creating a named num from two columns
  return(ranks)
}

ranks.gastroc <- getRanks(res.gastroc, annot)
ranks.soleus <- getRanks(res.soleus, annot)
# TODO: why (again) is the soleus gene count seemingly 300 below soleus gene count / ranks count
# -> seems because of e.g. the cutoff at DESeq
```

## ranks distribution

```{r ranks_barplot, echo=FALSE}
# no idea how to plot this with ggplot (one column) ...

# ggpubr::ggarrange(
# TODO: prettify
# barplot.file <- "./plots/04_barplot_ranks.png"
# if (!file.exists(barplot.file)) {
#   png(barplot.file)
    par(mfrow = c(1, 2))
    barplot(sort(ranks.gastroc, decreasing = T), main = "Wald Test ranks, gastroc")
    barplot(sort(ranks.soleus, decreasing = T), main = "Wald Test ranks, soleus")
  # dev.off()
# }
# )
```

## duplicate entrezgene_ids

duplicate entrezgene ids (multiple entrez are mapped to the same gene name)

Thus a quick look if any of these genes can be simply omitted. Like if the gene_type is "other" or "tRNA"

```{r include=FALSE}
# TODO: do not use annot, but the merge? (actually used genes!)
# first looking at ENSEMBL:
duplicate_ENSEMBL <- annot[duplicated(annot$GeneID), ] %>%
  dplyr::group_by(GeneID, gene_biotype) %>%
  summarise(n = n())

# looking at gene_names(ext):
duplicate_geneNames <- annot[duplicated(annot$external_gene_name), ] %>% 
  dplyr::group_by(GeneID, gene_biotype) %>%
  summarise(n = n())

# duplicates have always the same gene_biotype! (in no more than one group occurs the same GeneID)
anyDuplicated(duplicate_ENSEMBL$GeneID)   # 0
anyDuplicated(duplicate_geneNames$GeneID) # 0

# are all gene_name duplicates in ENS duplicates?
sum(duplicate_ENSEMBL$GeneID %in% duplicate_geneNames$GeneID) %>%
  sprintf(
    "%d / %d ENSEMBL duplications are also included in the duplicated gene_names",
    .,
    nrow(duplicate_ENSEMBL)
  )

diff_ENS_gene <- nrow(duplicate_geneNames) -nrow(duplicate_ENSEMBL)
```

Since all ENSEMBL duplicates are also found in the gene_name duplicates, using the ENSEMBL as id for the ranks would reduce the number of duplicates by `r diff_ENS_gene`.

actually most of them are "protein coding" and will not be omitted. to be continued ...

```{r eval=FALSE, include=FALSE}
# TODO: do a e.g. bar-plot with the distribution of gene_biotypes of the duplicates
#       vs the whole genome
# create the df for plotting

ENS <- duplicate_ENSEMBL %>%
  dplyr::group_by(gene_biotype) %>%
  summarise(count = sum(n))


GN <- duplicate_geneNames %>%
  dplyr::group_by(gene_biotype) %>%
  summarise(count = sum(n))



ggplot(data=df2, aes(x=dose, y=len, fill=supp)) +
  geom_bar(stat="identity")

```

# loading pathways

Pathways are provided by <http://www.gsea-msigdb.org/gsea/msigdb/mouse/collections.jsp>

For now the Canonical pathways are used. These gene sets represent biological a biological process. They are composed from the following databases taking a subset of CP:

| database     | gene sets |
|--------------|-----------|
| BioCarta     | 252       |
| Reactome     | 1249      |
| WikiPathways | 186       |

```{r reading_pathways, include=FALSE}
CGP <- qusage::read.gmt("./data/pathways/m2.cp.v2022.1.Mm.entrez.gmt") # canonical pathways (1687 gene sets)

# previously used pathways
# MH <- qusage::read.gmt("./data/pathways/mh.all.v2022.1.Mm.entrez.gmt") # 50 hallmark genes
# M2 <- qusage::read.gmt("./data/pathways/m2.all.v2022.1.Mm.entrez.gmt") # curated gene set with 2600 genes
```

# applying fgsea

    fgseaRes <- fgsea(
      pathways = CGP,
      stats    = ranks,
      minSize  = 15,
      maxSize  = `r params$fgsea.maxSize`
    )

```{r fgsea_res_load, include=FALSE}
# ' returns the fgsea result
# ' `tissue` needs to be one of {"soleus", "soleus"}
# ' Also saves the results locally to avoid too much queries
get_fgseaRes <- function(tissue, ranks, maxSize=params$fgsea.maxSize, pathways=CGP, saveResults=T) {
  robjects.path <- file.path(".", "data", "Robjects")
  fgseaRes.path <- file.path(
    robjects.path,
    "04_fgsea_results",
    tissue,
    paste0("maxSize_", params$fgsea.maxSize, ".rds")
  )
  fgseaRes.dir <- dirname(fgseaRes.path)
  
  if (file.exists(fgseaRes.path) & !params$reevaluate) {
    message("fgsea result found in directory! Previous version will be loaded ...")
    return(readRDS(file = fgseaRes.path))
  } else {
    # perform fgsea and save the result
    fgseaRes <- fgsea(
      pathways = pathways,
      stats    = ranks,
      minSize  = 15,
      maxSize  = maxSize
    )
    
    if (saveResults) {
      if (!dir.exists(fgseaRes.dir))
        dir.create(fgseaRes.dir, recursive = T)
      saveRDS(fgseaRes, file = fgseaRes.path)
    }
    return(fgseaRes)
  }
}

fgseaRes.gastroc <- get_fgseaRes("gastroc", ranks.gastroc, pathways=CGP)
fgseaRes.soleus <- get_fgseaRes("soleus", ranks.soleus, pathways=CGP)
```

## most differential regulated pathways, both tissues

using `NES` from the fgsea result filtering on the set ``` pCutoff=``r params$pCutoff ``` yields the following plot:

```{r topDiff.both, warning=FALSE}

pCutoff <- params$pCutoff
fgseaRes.combined <- merge(
  data.frame(fgseaRes.gastroc[, c("pathway", "NES", "padj")]),
  data.frame(fgseaRes.soleus[, c("pathway", "NES", "padj")]),
  by = "pathway",
  suffixes = c(".ga", ".sol")
) %>%
  filter(padj.ga < pCutoff | padj.sol < pCutoff) %>%
  mutate(
    diff.exp = case_when(
      NES.ga  < 0 & NES.sol < 0 & padj.ga < pCutoff & padj.sol < pCutoff ~ "both down",
      NES.ga  > 0 & NES.sol > 0 & padj.ga < pCutoff & padj.sol < pCutoff ~ "both up",
      NES.ga  < 0 & NES.sol > 0 & padj.ga < pCutoff & padj.sol < pCutoff ~ "gastrocnemius down, soleus up",
      NES.ga  > 0 & NES.sol < 0 & padj.ga < pCutoff & padj.sol < pCutoff ~ "gastrocnemius up, soleus down",
                                  padj.ga < pCutoff & padj.sol > pCutoff ~ "only gastrocnemius",
      # NES.ga  > 0 &               padj.ga < pCutoff & padj.sol > pCutoff ~ "ga up",
                                  padj.ga > pCutoff & padj.sol < pCutoff ~ "only soleus",
      # NES.sol > 0 &               padj.ga > pCutoff & padj.sol < pCutoff ~ "sol up",
      TRUE ~ "different"
    )
  )

# final plot
p <- ggplot(fgseaRes.combined, aes(x = NES.ga, y = NES.sol, text=pathway)) +
  geom_vline(xintercept = 0) + 
  geom_hline(yintercept = 0) + 
  geom_point(aes(color = diff.exp)) +
  # scale_color_manual(values = c("red", "chartreuse1", "bisque", "royalblue")) +
  labs(x = "gastrocnemius", y = "soleus", color = "significantly\ndifferentially\nexpressed") +
  # ggrepel::geom_label_repel(max.overlaps = 20) + 
  ggtitle(label = "Normalized Enrichment Score") +
  theme_bw()

ggsave(filename = file.path("plots", "04_gsea_scatter.svg"), p)
p

# interactive:
# plotly::ggplotly(p, tooltip = "all")
```

### barplot

```{r gsea_scatter_barplot}
p <- ggplot(fgseaRes.combined, aes(x = diff.exp)) +
  geom_bar(aes(fill = diff.exp)) +
  theme_bw()

ggsave(filename = file.path("plots", "04_gsea_scatter_barplot.svg"), p)
p
```

### Venn/Euler-Diagram

```{r vennDiagramGSEA}
venn.colors <- c(params$tissue_pal, scales::hue_pal()(4))

sign_geneSets_gastroc <-
  data.frame(fgseaRes.gastroc[, c("pathway", "padj")]) %>%
  filter(padj < params$pCutoff) %>% 
  pull(pathway)


sign_geneSets_soleus <-
  data.frame(fgseaRes.soleus[, c("pathway", "padj")]) %>%
  filter(padj < params$pCutoff) %>% 
  pull(pathway)

# only the two tissues
gene_sets <- list(
  "gastroc" = sign_geneSets_gastroc,
  "soleus" = sign_geneSets_soleus#,
  # "gastroc&soleus" = sign_gene_stats$shared_sig_genes
)

# 1st option: euler two tissues
p <- plot(
  euler(gene_sets),
  quantities = T,
  legend = list(side = "right"),
  fills = venn.colors,
  main = "significant gene sets (GSEA)"
)
ggsave(filename = file.path("plots", "03_euler.svg"), p)
p

# 2nd option: venn two tissues
library(eulerr)
p <- plot(
  eulerr::venn(gene_sets),
  fills = params$tissue_pal,
  main = "significant gene sets (GSEA)"
)
ggsave(filename = file.path("plots", "03_venn.svg"), p)
p
```



### dotplot

```{r echo=FALSE}
library(patchwork)
combined_dotplot <-
  function(group,
           fgseaRes.combined = fgseaRes.combined,
           max_label_length = 25, topn=6e6, sort_by_gastroc=T) {
    
    # get pathways of the respective group
    pathways <- filter(fgseaRes.combined, diff.exp == group)$pathway
    
    gastroc.df <-
      filter(fgseaRes.gastroc, pathway %in% pathways)
    soleus.df <-
      filter(fgseaRes.soleus, pathway %in% gastroc.df$pathway)
    
    if (sort_by_gastroc) {
      gastroc.df <- gastroc.df %>% 
        top_n(topn, wt = abs(NES)) %>%
        arrange(NES)
      soleus.df <- soleus.df %>% 
        .[match(gastroc.df$pathway, pathway)]
    } else {
      soleus.df <- soleus.df %>% 
        top_n(topn, wt = abs(NES)) %>%
        arrange(NES)
      gastroc.df <- gastroc.df %>% 
        .[match(soleus.df$pathway, pathway)]
    }
	
    padj_limits <-
      c(min(gastroc.df$padj, soleus.df$padj),
        max(gastroc.df$padj, soleus.df$padj))
    
    NES_limits <- 
      c(min(gastroc.df$NES, soleus.df$NES),
        max(gastroc.df$NES, soleus.df$NES))
    
    p.gastroc <- fgsea_dotplot(gastroc.df, max_label_length, padj_limits, NES_limits)

    p.soleus <- fgsea_dotplot(soleus.df, max_label_length, padj_limits, NES_limits)
    
    # adjust plots
    p.gastroc <- p.gastroc +
      theme(
        legend.position = "none",
        plot.margin = unit(c(0, 0, 0, 0), "npc"),
      ) +
      ylab("NES\n(gastroc)") + 
      xlab("")
    p.soleus <- p.soleus +
      theme(
        axis.text.y = element_blank(),
        plot.margin = unit(c(0, 0, 0, 0), "npc")
      ) +
      ylab("NES\n(soleus)") + 
      xlab("")
    
    return(p.gastroc + p.soleus)
  }


fgsea_dotplot <-
  function(fgseaRes.df,
           max_label_length=25,
           padj_limits=NULL,
           NES_limits=NULL) {
  size_breaks <- seq(0,200,by=50)
  size_breaks[1] <- 10
  size_range <- c(2,8)
  
  # adjust label size if the plot has too many sets:
  label_size <- 8
  nsets <- nrow(fgseaRes.df)
  if (nsets > 15) {
    
    label_size <- label_size - (0.05 * nsets)
    max_label_length <- nsets + 10
    size_range <- size_range -1
  }
  
  fgseaRes_prep.df <- fgseaRes.df %>%
    # TODO: might need to be changed if other labels are used (like description)
    mutate(pathway = gsub("_", " ", pathway) %>% tolower()) %>%
    mutate(pathway = factor(pathway, levels = pathway))
  # the factor levels might be different than the order of the rows
  
  ggplot(fgseaRes_prep.df, aes(x = pathway, y = NES)) +
    geom_point(aes(size = size, color = padj)) +
    scale_color_gradient(low = "red",
                         high = "blue",
                         limits = padj_limits) +
    scale_size_continuous(range = size_range,
                          breaks = size_breaks,
                          limits = c(10, 200)) +
    scale_y_continuous(limits = NES_limits) +
    # scale_x_discrete(guide = guide_axis(check.overlap = TRUE))+
    scale_x_discrete(labels = scales::label_wrap(max_label_length)) +
    xlab("Gene Set") + ylab("NES") +
    labs(size = "Count", color = "p.adjust") +
    theme_bw() +
    coord_flip() +
    theme(axis.text.y = element_text(size = label_size))
  }
```

> Note: Different to most other plots, the dotplots seem to be created best by running the chunks manually. This results in automatic axis scaling with more entries, so that the labels do not overlap (which is curiously not the case if remotely knitting)!


#### dotplot: "both upregulated"
only 7 gene sets => fits well in the plot
```{r dotplotBothUp}
group = "both up"
p_combined <- combined_dotplot(group, fgseaRes.combined)

ggsave(filename = file.path("plots", paste0("04_gsea_dotplot_", group, ".svg")), p_combined)
p_combined
```


#### dotplot: "both down"
gets adjusted by the function well. The .svg file looks okay
```{r dotplotBothDown}
group = "both down"
p_combined <- combined_dotplot(group, fgseaRes.combined)

 ggsave(filename = file.path("plots", paste0("03_gsea_dotplot_", group, ".svg")), p_combined)
p_combined
```


#### dotplot: "only gastrocnemius"
gets adjusted by the function well. The .svg file looks okay

```{r dotplotGastroc}
group = "only gastrocnemius"
p_combined <- combined_dotplot(group, fgseaRes.combined, max_label_length = 100)

ggsave(filename = file.path("plots", paste0("03_gsea_dotplot_", group, ".svg")), p_combined)
p_combined
```

```{r dotplotGastrocSingle}
group = "only gastrocnemius"
pathways <- filter(fgseaRes.combined, diff.exp == group)$pathway

gastroc.df <-
  filter(fgseaRes.gastroc, pathway %in% pathways) %>%
  arrange(NES)

p.gastroc <- fgsea_dotplot(gastroc.df, max_label_length = 100)
ggsave(filename = file.path("plots", paste0("03_gsea_dotplot_", group, "_single.svg")), p.gastroc)
p.gastroc
```



#### dotplot: "only soleus"
gets adjusted by the function well. The .svg file looks okay

```{r dotplotSoleus}
group = "only soleus"
p_combined <- combined_dotplot(group, fgseaRes.combined, max_label_length = 100, sort_by_gastroc = F)

ggsave(filename = file.path("plots", paste0("03_gsea_dotplot_", group, ".svg")), p_combined)
p_combined
```


```{r dotplotSoleusSingle}
group = "only soleus"
pathways <- filter(fgseaRes.combined, diff.exp == group)$pathway

soleus.df <-
  filter(fgseaRes.soleus, pathway %in% pathways) %>%
  arrange(NES)

p.soleus <-
  fgsea_dotplot(soleus.df, max_label_length = 100)
ggsave(filename = file.path("plots", paste0("03_gsea_dotplot_", group, "_single.svg")), p.soleus)
p.soleus
```

#### dotplot: top20
```{r include=FALSE}
for (group in unique(fgseaRes.combined$diff.exp)) {
  p_combined <- combined_dotplot(group, fgseaRes.combined)
  
  ggsave(filename = file.path("plots", paste0("03_gsea_dotplot_", group, ".svg")), p_combined)
  print(p_combined)
}
```


## Enrichment score plot

ordering pathways by padj values and using `ES` to

```{r fn_get_top_pathways}
# ' obtain top pathways ordered by padj and use `ES` for up or down regulation
get_top_pathways <- function(fgseaRes, up = TRUE, pCutoff=params$pCutoff, n=10) {
  .updown <- ifelse(up, `>`, `<`)
  
  top.pathways <- fgseaRes %>%
    filter(.updown(ES,0), padj < pCutoff) %>%
    arrange(padj) %>% 
    slice_head(n=n)
  
 return(top.pathways) 
}
```

plot for top up and down regulated pathways

```{r}
# ' plots top n enrichment plots for the given fgsea result
plot_top_enrichment <- function(fgseaRes, pathways, ranks, n = 9, up = TRUE) {
  # extracting the top n pathways
  top.pathways <- get_top_pathways(fgseaRes, up=up, pCutoff=params$pCutoff, n=n)
  
  plot.list <- list()
  # lims <- list("x" = c(0,17000), "y" = c(-0.8,0.0))
  
  for (i in 1:nrow(top.pathways)) {
    # filling plot.list with enrichmentPlots 
    # TODO: how can I use facet_wrap for this?
    pathway <- top.pathways[i]$pathway
    plt <- plotEnrichment(pathways[[pathway]], ranks) +
      # TODO: adjust yaxis to the same scale
      # TODO: keep axis.text.x only on the lower row
      # TODO: keep axis.text.y only on the right column
      theme(
        axis.title.x = element_blank(),
        axis.title.y = element_blank()
      ) # +
      # coord_cartesian(xlim = lims$x, ylim = lims$y)
    plot.list[[i]] <- plt
  }
    
  arrange_plts(plot.list)
}

# ' helper function to arragen the plot from the enrichment
arrange_plts <- function(plt.list) {
  nplts <- length(plt.list)
  plt <- plt.list[1]
  xlab <- plt$labels$x
  ylab <- plt$labels$y
  
  # set axis to the same scale
  lims <- list("x" = c(0, 17000), "y" = c(-0.8, 0.0))
  
  # remove axis
  
  # arrange the plots
  fig_labels <- LETTERS[1:nplts]
  
  patchwork::wrap_plots(plt.list, )
  
  figure <- ggpubr::ggarrange(plotlist = plt.list,
                              labels = fig_labels) %>%
    annotate_figure(left = text_grob(ylab, rot = 90),
                    bottom = text_grob(xlab))
 
  # TODO: remove all x-axis labels except lower row
  # get dimensions
  figure$layers
   
  return(figure)
}



# plot_labels <-
#     data.frame("label" = LETTERS[1:10], "pathway" = top.pathways)
# knitr::kable(caption = "plot labels", plot_labels)

```

### gastroc up

```{r}
plot_top_enrichment(fgseaRes.gastroc, CGP, ranks.gastroc, up=T)

# TODO: add plot labels to return argument of plot_top_enrichment (use list probably)
plot_labels <-
    data.frame("label" = LETTERS[1:9], "pathway" = get_top_pathways(fgseaRes.gastroc, up=T, n=9)$pathway)
knitr::kable(caption = "plot labels", plot_labels)
```

### gastroc down

```{r}
plot_top_enrichment(fgseaRes.gastroc, CGP, ranks.gastroc, up=F)
plot_labels <-
    data.frame("label" = LETTERS[1:9], "pathway" = get_top_pathways(fgseaRes.gastroc, up=F, n=9)$pathway)
knitr::kable(caption = "plot labels", plot_labels)
```

### soleus up

```{r}
plot_top_enrichment(fgseaRes.soleus, CGP, ranks.soleus, up=T)

plot_labels <-
    data.frame("label" = LETTERS[1:9], "pathway" = get_top_pathways(fgseaRes.soleus, up=T, n=9)$pathway)
knitr::kable(caption = "plot labels", plot_labels)
```

### soleus down

```{r}
plot_top_enrichment(fgseaRes.soleus, CGP, ranks.soleus, up=F)
plot_labels <-
    data.frame("label" = LETTERS[1:9], "pathway" = get_top_pathways(fgseaRes.soleus, up=F, n=9)$pathway)
knitr::kable(caption = "plot labels", plot_labels)
```

## GSEA table plot

### gastroc

top significant pathways:

```{r}
# creating up and down regulated pathway vectors separately to maintain order

topUp <- get_top_pathways(fgseaRes.gastroc, up=T, pCutoff = params$pCutoff, n=10)
topDown <- get_top_pathways(fgseaRes.gastroc, up=F, pCutoff = params$pCutoff, n=10)
topPathways <- bind_rows(topUp, topDown) %>%
  arrange(-NES) %>%
  pull(pathway)

plotGseaTable(
  pathways = CGP[topPathways],
  stats = ranks.gastroc,
  fgseaRes = fgseaRes.gastroc,
  gseaParam = 0.5,
  render = TRUE
) %>%
  ggpubr::as_ggplot() # needed since, for whatever reason only `NULL` gets returned if `plotGseaTable` is rendered inline
```

### soleus

top significant pathways:

```{r}
# creating up and down regulated pathway vectors separately to maintain order

topUp <- get_top_pathways(fgseaRes.soleus, up=T, pCutoff = params$pCutoff, n=10)
topDown <- get_top_pathways(fgseaRes.soleus, up=F, pCutoff = params$pCutoff, n=10)
topPathways <- bind_rows(topUp, topDown) %>%
  arrange(-NES) %>%
  pull(pathway)

plotGseaTable(
  pathways = CGP[topPathways],
  stats = ranks.soleus,
  fgseaRes = fgseaRes.soleus,
  gseaParam = 0.5,
  render = TRUE
) %>%
  ggpubr::as_ggplot() # needed since, for whatever reason only `NULL` gets returned if `plotGseaTable` is rendered inline
```

### list of all significant pathways

pathways will be sorted here by the absolute sum of the NES...

#### both down

```{r}
fgseaRes.combined %>% 
  filter(diff.exp == "both down") %>% 
  mutate(NES = abs(NES.ga) + abs(NES.sol)) %>% 
  select(pathway, NES) %>% 
  arrange(desc(NES)) %>%
  rmarkdown::paged_table(options = list(cols.min.print = 2))
```

#### both up

```{r}
fgseaRes.combined %>% 
  filter(diff.exp == "both up") %>% 
  mutate(NES = abs(NES.ga) + abs(NES.sol)) %>% 
  select(pathway, NES) %>% 
  arrange(desc(NES)) %>%
  rmarkdown::paged_table(options = list(cols.min.print = 2))
```

#### only gastroc

```{r}
fgseaRes.combined %>% 
  filter(diff.exp == "only gastrocnemius") %>% 
  mutate(NES = abs(NES.ga) + abs(NES.sol)) %>% 
  select(pathway, NES) %>% 
  arrange(desc(NES)) %>%
  rmarkdown::paged_table(options = list(cols.min.print = 2))
```

#### only soleus

```{r}
fgseaRes.combined %>% 
  filter(diff.exp == "only soleus") %>% 
  mutate(NES = abs(NES.ga) + abs(NES.sol)) %>% 
  select(pathway, NES) %>% 
  arrange(desc(NES)) %>%
  rmarkdown::paged_table(options = list(cols.min.print = 2))
```

```{r include = FALSE}
saveRDS(fgseaRes.combined, file = "./data/Robjects/04_fgseaRes.combined.rds")
```

# currentTODOs

-   [ ] looking at duplicate entrezgene_ids\
-   [ ] finding optimal `maxSize` (one sided curve)\
-   [ ] find out biological meaning of significant pathways\
-   [ ] improve fgsea plots\
    -   [ ] improve labels (not overlapping with axes)\
    -   [ ] better align them ? [[https://www.biostars.org/p/438985/\\\\](https://www.biostars.org/p/438985/){.uri}](%5Bhttps://www.biostars.org/p/438985/%5D(https://www.biostars.org/p/438985/)%7B.uri%7D){.uri}
    -   [ ] maybe unify the axis scaling\
